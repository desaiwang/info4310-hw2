<html>

<head>
  <title>INFO 4310 - HW2</title>

  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <style>
    .countries {
      stroke: white;
      stroke-width: 1px;
      fill: #bbb;
    }

    .tractsTreeCount {
      stroke: white;
      stroke-width: 2px;
    }

    .row {
      display: flex;
      flex-direction: row;
      justify-content: center
    }

    .column {
      display: flex;
      flex-direction: column;
    }

    .annotation {
      font-size: 12px;
      margin-top: -15px;
      margin-left: 40px
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
  </style>

</head>

<body>
  <div style="margin-top:30px">
    <h2 style="text-align: center"> Exploring Power Plants Around the World</h2>
    <div class="row 1">
      <svg id="mapGlobal" width="1500" height="1000"></svg>
      <div>
        <svg width="300" height="200">
          <text id="plantName" y="10" alignment-baseline="hanging"></text>
          <text id="plantCapacity" y="25" alignment-baseline="hanging"></text>
        </svg>

      </div>
    </div>
    <svg id="map" width="1500" height="1000"></svg>


  </div>

  </div>


  <script>

    //row 1 elements
    const svgGlobal = d3.select("#mapGlobal");
    const width = svgGlobal.attr("width");
    const height = svgGlobal.attr("height");
    const margin = { top: 20, right: 20, bottom: 20, left: 20 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;

    const viewport = svgGlobal.append("g");
    // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // map geojson
    const requestData = async function () {

      //load power plant data
      const powerPlants = await d3.csv("./global_power_plant_database.csv", d3.autoType);
      const countries = await d3.json("./countries.geojson");

      console.log(powerPlants);
      console.log(countries);

      // Mercator projection
      var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);

      //scales for income and treeCount
      const capacityExtent = d3.extent(powerPlants, d => d["capacity_mw"]);
      const capacityScale = d3.scaleLog()
        .domain(capacityExtent)
        .range([1, 5]);
      console.log(capacityExtent)

      powerPlants.forEach(d => {
        d.Position = projection([d.longitude, d.latitude]);
      })

      // countries for base map
      let countryBoundaries = viewport.selectAll("path.countries").data(countries.features)
        .join("path")
        .attr("class", "countries")
        .attr("d", path);

      // drawLegend("#legendIncome", incomeColorScale, d3.format("$.2s"));

      let circles = viewport.selectAll("circle").data(powerPlants)
        .join("circle")
        .attr("cx", d => d.Position[0])
        .attr("cy", d => d.Position[1])
        .attr("r", d => capacityScale(d["capacity_mw"]))
        .attr("fill", "blue")
        .attr("opacity", 0.5);

      circles.on("mouseover", function () {
        let name = d3.select(this).datum()["name"];
        let capacity = d3.select(this).datum()["capacity_mw"];

        d3.select("#plantName").text(`Name: ${name}`);
        d3.select("#plantCapacity").text(`Capacity: ${capacity} mW`);
      });

      circles.on("mouseout", function () {
        d3.select("#plantName").text("");
        d3.select("#plantCapacity").text("");
      });

      // // census tracts for tree count map
      // mapTreeCount.selectAll("path.tractsTreeCount").data(tracts.features)
      //   .join("path")
      //   .attr("class", "tractsTreeCount")
      //   .attr("d", path)
      //   .attr("fill", d => treeCountColorScale(d.properties["TreeCount"]));
      // drawLegend("#legendTreeCount", treeCountColorScale, d3.format(".2s"));

      var zoom = d3.zoom()
        // .scaleExtent([1, 20])
        // .translateExtent([[-50, -50], [mapWidth + 50, mapHeight + 50]])  // to lock to edges
        .on("zoom", mapZoomed);

      // viewport.on(".zoom", function (event) {
      //   console.log(event);
      // })

      svgGlobal.call(zoom);
      svgGlobal.call(zoom.transform, d3.zoomIdentity);

      // from INFO3300 lecture on panning and zooming
      function mapZoomed({ transform }) {

        console.log(transform);
        // Transform the group object to reflect the zoom action
        viewport.attr("transform", transform.toString());
        // NOTE: we could also instead adjust projection and path to account for the zoom
        //  However, projections can be time-consuming to calculate, leading to laggy interactions
        //  For some projections like orthographic, you need to recompute the projection to deliver a
        //   consistent user experience (e.g. adjust lambda for the projection to rotate the globe)

        // Divide by scale to make sure strokes remain a consistent width during zooming
        countryBoundaries
          .style("stroke-width", 1 / transform.k);
        circles.attr("r", d => capacityScale(d["capacity_mw"]) / transform.k);
        // console.log(viewport.select(".plantLocation"));

        // Expose county layer when sufficiently zoomed
        // viewport.select(".county-outline")
        //   .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
        // viewport.selectAll(".county")
        //   .attr("visibility", (transform.k > 3) ? "visible" : "hidden");

      }

    }
    requestData();
  </script>

  <script id="helper function">

    function sumTreeCount_avgMeanIncome(geodata) {
      let treeCount = 0;
      let meanIncomeSum = 0;

      geodata.features.forEach(d => {
        treeCount += d.properties['TreeCount'];
        meanIncomeSum += d.properties["est household mean income"];
      })

      let meanIncome = meanIncomeSum / geodata.features.length

      return [treeCount, meanIncome]
    }
    //legend function from INFO 3300 lecture notes
    function drawLegend(legendSelector, legendColorScale, stringFormatter) {

      const offsets = {
        width: 30,
        top: 2,
        bottom: 24
      };

      const stepSize = 4;

      const minMaxExtendPercent = 0;


      const legend = d3.select(legendSelector);
      const legendHeight = legend.attr("height");
      const legendBarWidth = legend.attr("width") - (offsets.width * 2);
      const legendMinMax = d3.extent(legendColorScale.domain());


      const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
      const barHeight = legendHeight - offsets.top - offsets.bottom;


      let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
      legendMinMax[1] + minMaxExtension])
        .range([0, legendBarWidth - 10]);
      let barAxis = d3.axisBottom(barScale);


      let bar = legend.append("g")
        .attr("class", "legend colorbar")
        .attr("transform", `translate(${offsets.width},${offsets.top})`)


      if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
        let thresholds = [];
        if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
        else { thresholds = legendColorScale.quantiles() }

        let barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

        barAxis.tickValues(barThresholds).tickFormat(stringFormatter);

        for (let i = 0; i < barThresholds.length - 1; i++) {
          let dataStart = barThresholds[i]; let dataEnd = barThresholds[i + 1];
          let pixelStart = barAxis.scale()(dataStart); let pixelEnd = barAxis.scale()(dataEnd); bar.append("rect").attr("x",
            pixelStart).attr("y", 0).attr("width", pixelEnd - pixelStart).attr("height", barHeight).style("fill",
              legendColorScale((dataStart + dataEnd) / 2.0));
        }
      } else if (legendColorScale.hasOwnProperty('rangeRound')) {
        for
          (let i = 0; i < legendBarWidth; i = i + stepSize) {
          let center = i + (stepSize / 2); let
            dataCenter = barAxis.scale().invert(center); if (dataCenter < legendMinMax[0]) {
              bar.append("rect").attr("x", i)
                .attr("y", 0).attr("width", stepSize).attr("height", barHeight).style("fill", legendColorScale(legendMinMax[0]));
            } else if (dataCenter < legendMinMax[1]) {
              bar.append("rect").attr("x", i).attr("y", 0).attr("width", stepSize)
                .attr("height", barHeight).style("fill", legendColorScale(dataCenter));
            } else {
            bar.append("rect").attr("x", i)
              .attr("y", 0).attr("width", stepSize).attr("height", barHeight).style("fill", legendColorScale(legendMinMax[1]));
          }
        }
      } else {
        let nomVals = legendColorScale.domain().sort(); let barScale = d3.scaleBand().domain(nomVals).range([0,
          legendBarWidth]).padding(0.05); barAxis.scale(barScale); nomVals.forEach(d => {
            bar.append("rect")
              .attr("x", barScale(d))
              .attr("y", 0)
              .attr("width", barScale.bandwidth())
              .attr("height", barHeight)
              .style("fill", legendColorScale(d));
          });
      }

      legend.append("g")
        .attr("class", "legend axis")
        .attr("class", "colorLegendfont")
        .attr("transform", `translate(${offsets.width},${offsets.top + barHeight + 5})`)
        .call(barAxis);

    }

  </script>
</body>

</html>