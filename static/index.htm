<html>

<head>
  <title>INFO 4310 - HW2</title>
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  <link href="./style.css" rel="stylesheet" type="text/css">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <style>
    .countries {
      stroke: white;
      stroke-width: 1px;
      fill: #e8e8e8;
    }

    .row {
      display: flex;
      flex-direction: row;
      justify-content: center
    }

    .column {
      display: flex;
      flex-direction: column;
    }

    .annotation {
      font-size: 12px;
      margin-top: -15px;
      margin-left: 40px
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }

    .serie rect {
      fill-opacity: 0.8;
    }

    .serie:hover rect {
      fill-opacity: 1;
    }
  </style>

</head>

<body>
  <div style="margin-top:30px">
    <h2 style="text-align: center"> Exploring Power Plants Around the World</h2>
    <h5 style="text-align: center; margin-top: -65px; margin-bottom: 50px"> Natalia Jordan (naj46) and Desai Wang
      (dw584)</h5>

    <div class="row 1">
      <svg id="mapGlobal" width="1000" height="600">
        <!-- <text id="plantName" y="10" x="1000" alignment-baseline="hanging"></text>
        <text id="plantCapacity" y="20" x="1000" alignment-baseline="hanging"></text> -->
      </svg>
      <!-- <div>
        <svg width="300" height="200">
        </svg>

      </div> -->
    </div>
    <div id="container" style="width: 1000px; height: 600px;"></div>
    <!-- <svg id="map" width="1500" height="1000"></svg> -->
    <div style="margin-top:100px">
      <svg id="primaryFuel" width="1200" height="500"></svg>
      <svg id="pfCountry" width="1200" height="500"></svg>
      <svg id="powerPlants" width="1200" height="500"></svg>
    </div>




  </div>

  </div>


  <script>

    //establish color mapping for fuel types
    const primaryFuelTypes = ['Solar', 'Wind', 'Hydro', 'Wave and Tidal', 'Geothermal', 'Biomass', 'Gas', 'Oil', 'Nuclear', 'Coal', 'Waste', 'Petcoke', 'Storage', 'Cogeneration', 'Other'];

    colors = [
      "#b2df8a",
      "#a6cee3",
      "#1f78b4",
      "#33a02c",
      "#ff7f00",
      "#fb9a99",
      "#e31a1c",
      "#fdbf6f",
      "#cab2d6",
      "#6a3d9a",
      "#b15928",
      "#000000",
      "#cccccc",
      "#fdda24",
      "#b15928"
    ];

    const colorScale = d3.scaleOrdinal()
      .domain(primaryFuelTypes)
      .range(colors);


    //row 1 elements
    const svgGlobal = d3.select("#mapGlobal");
    const width = svgGlobal.attr("width");
    const height = svgGlobal.attr("height");
    const margin = { top: 20, right: 20, bottom: 20, left: 20 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;

    const viewport = svgGlobal.append("g");
    // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // map geojson
    const requestData = async function () {

      //load power plant data
      const powerPlants = await d3.csv("./global_power_plant_database.csv", d3.autoType);
      const countries = await d3.json("./countries.geojson");

      // console.log(powerPlants);
      //console.log("")
      console.log("countries", countries);

      // Mercator projection
      var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);

      // power capacity
      const capacityExtent = d3.extent(powerPlants, d => d["capacity_mw"]);
      const capacityScale = d3.scaleLog()
        .domain(capacityExtent)
        .range([1, 5]);
      // console.log(capacityExtent)

      powerPlants.forEach(d => {
        d.Position = projection([d.longitude, d.latitude]);
        d.Color = colorScale(d["primary_fuel"]);
        d.Radius = capacityScale(d["capacity_mw"]);
      })

      // countries for base map
      let countryBoundaries = viewport.selectAll("path.countries").data(countries.features)
        .join("path")
        .attr("class", "countries")
        .attr("d", path);

      const container = d3.select("#container").style("position", "relative");

      // Add a canvas element


      const svg = container.append("svg")
        .attr("width", width)
        .attr("height", height)
        .style("position", "absolute")
        .style("top", 0)
        .style("left", 0);

      const canvas = container.append("canvas")
        .attr("width", width)
        .attr("height", height)
        .style("position", "absolute")
        .style("top", 0)
        .style("left", 0);

      const mapAnnotations = container.append("svg")
        .attr("width", width)
        .attr("height", height)
        .style("position", "absolute")
        .style("top", 0)
        .style("left", 0);

      const mapArea = svg.append("g");

      mapArea.selectAll("path.countries").data(countries.features)
        .join("path")
        .attr("class", "countries")
        .attr("d", path);

      const interactiveArea = mapAnnotations.append("g");
      interactiveArea.append("rect")
        .attr("width", width)
        .attr("height", height)
        .attr("x", 0)
        .attr("y", 0)
        .attr("opacity", 0);
      const label = mapAnnotations.append("text").attr("x", margin.left + 10).attr("y", margin.top + 10);
      const context = canvas.node().getContext('2d');

      interactiveArea.call(d3.zoom()
        .scaleExtent([1, 20])
        .on("zoom", ({ transform }) => zoomed(transform)));
      let currTransform = d3.zoomIdentity;

      //zooming features
      let r = 2;
      d3.select(context.canvas).call(d3.zoom()
        .scaleExtent([1, 20])
        .on("zoom", ({ transform }) => zoomed(transform)));

      function zoomed(transform) {
        mouseExited(); //temporarily disable circle highlighting

        currTransform = transform;

        mapArea.attr("transform", transform);

        console.log(transform);
        context.save();
        context.clearRect(0, 0, width, height);
        context.translate(transform.x, transform.y);
        context.scale(transform.k, transform.k);
        context.beginPath();

        powerPlants.forEach((d, i) => {
          let x = d.Position[0];
          let y = d.Position[1];
          let rad = d.Radius;
          let color = d.Color;

          context.fillStyle = color;
          context.beginPath();
          context.arc(x, y, rad / transform.k, 0, 2 * Math.PI);
          context.fill();
        });
        context.restore();
      }
      zoomed(d3.zoomIdentity);


      //CODE FOR INTERACTIVITY
      // context.save();
      // context.clearRect(0, 0, width, height);
      // context.beginPath();

      // powerPlants.forEach((d, i) => {
      //   let x = d.Position[0];
      //   let y = d.Position[1];
      //   let rad = d.Radius;
      //   let color = d.Color;

      //   context.fillStyle = color;
      //   context.beginPath();
      //   context.arc(x, y, rad, 0, 2 * Math.PI);
      //   context.fill();
      // });
      // context.restore();

      const delaunay = d3.Delaunay.from(powerPlants, d => d.Position[0], d => d.Position[1]);

      let currentTarget = -1;
      interactiveArea.on("mousemove", function (event) {

        let loc = d3.pointer(event);

        loc_x = (loc[0] - currTransform.x) / currTransform.k;
        loc_y = (loc[1] - currTransform.y) / currTransform.k;

        console.log(currTransform)
        console.log(loc[0], loc[1]);
        console.log(loc_x, loc_y);

        let index;
        if (currentTarget === -1) {
          // Does a sweep of triangles, which should be O(sqrt(N)) in most cases
          index = delaunay.find(loc_x, loc_y);   // returns index of closest point
        }
        else {
          // With a known point index that's nearby, you can speed up the lookups dramatically
          index = delaunay.find(loc_x, loc_y, currentTarget)
        }
        // console.log(loc, index);

        if (index !== currentTarget) {
          // Make our "mouseover" function
          console.log("mouseover");
          currentTarget = index;
          mouseExited();
          mouseEntered(index, loc[0], loc[1]);
        }
      });
      // Also trigger "mouseout" when leaving interactive area
      interactiveArea.on("mouseout", () => {
        currentTarget = -1;
        mouseExited();
      })


      function mouseEntered(i) {
        let d = powerPlants[i];

        interactiveArea.append("circle")
          .attr("id", "highlight")
          .attr("cx", d.Position[0] * currTransform.k + currTransform.x)
          .attr("cy", d.Position[1] * currTransform.k + currTransform.y)
          .attr("r", 5)
          .attr("stroke", "black")
          .attr("fill", "none")
          // .attr("transform", `translate(${currTransform.x}, ${currTransform.y})`)
          // .attr("transform", `scale(${currTransform.k}, ${currTransform.k})`)
          ;
        label.text(d['name']);

      }

      function mouseExited() {
        d3.select("#highlight").remove();
        label.text("");
      }

      let circles = viewport.selectAll("circle").data(powerPlants)
        .join("circle")
        .attr("cx", d => d.Position[0])
        .attr("cy", d => d.Position[1])
        .attr("r", d => capacityScale(d["capacity_mw"]))
        .attr("fill", d => d.Color)
        .attr("opacity", 0.5);

      let plantName = svgGlobal.append("text").attr("id", "plantName").attr("x", 20).attr("y", height - 70);
      let plantCapacity = svgGlobal.append("text").attr("id", "plantCapacity").attr("x", 20).attr("y", height - 50);
      let plantPrimaryFuel = svgGlobal.append("text").attr("id", "plantPrimaryFuel").attr("x", 20).attr("y", height - 30);
      let plantCountry = svgGlobal.append("text").attr("id", "plantCountry").attr("x", 20).attr("y", height - 10);

      // plantName.text(`Name: TestTestTestTestTestTestTest`);
      // plantCapacity.text(`Capacity: Test mW`);
      // plantCountry.text(`Location: Test mW`);
      // plantPrimaryFuel.text(`Primary Fuel: Test mW`);

      circles.on("mouseover", function () {
        let name = d3.select(this).datum()["name"];
        let capacity = d3.select(this).datum()["capacity_mw"];
        let country = d3.select(this).datum()["country_long"];

        plantName.text(`Name: ${name}`);
        plantCapacity.text(`Capacity: ${capacity} mW`);
        plantCountry.text(`Location: ${country} mW`);
      });

      circles.on("mouseout", function () {
        plantName.text("");
        plantCapacity.text("");
        plantCountry.text("");
        // d3.select("#plantName").text("");
        // d3.select("#plantCapacity").text("");
      });

      // // census tracts for tree count map
      // mapTreeCount.selectAll("path.tractsTreeCount").data(tracts.features)
      //   .join("path")
      //   .attr("class", "tractsTreeCount")
      //   .attr("d", path)
      //   .attr("fill", d => treeCountColorScale(d.properties["TreeCount"]));
      // drawLegend("#legendTreeCount", treeCountColorScale, d3.format(".2s"));

      var zoom = d3.zoom()
        .scaleExtent([1.25, 20])
        .translateExtent([[-50, -50], [mapWidth + 50, mapHeight + 50]])  // to lock to edges
        .on("zoom", mapZoomed);



      // viewport.on(".zoom", function (event) {
      //   console.log(event);
      // })

      // viewport.call(zoom);
      // viewport.call(zoom.transform, d3.zoomIdentity.scale(1.6).translate(-180, 0));

      // from INFO3300 lecture on panning and zooming
      function mapZoomed({ transform }) {

        console.log(transform);
        // Transform the group object to reflect the zoom action
        viewport.attr("transform", transform);

        // Divide by scale to make sure strokes remain a consistent width during zooming
        countryBoundaries
          .style("stroke-width", 1 / transform.k);

        circles.attr("r", d => capacityScale(d["capacity_mw"]) / transform.k);
        // console.log(viewport.select(".plantLocation"));

        // Expose county layer when sufficiently zoomed
        // viewport.select(".county-outline")
        //   .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
        // viewport.selectAll(".county")
        //   .attr("visibility", (transform.k > 3) ? "visible" : "hidden");

      }

    }
    requestData();
  </script>

  <script id="helper function">

    function sumTreeCount_avgMeanIncome(geodata) {
      let treeCount = 0;
      let meanIncomeSum = 0;

      geodata.features.forEach(d => {
        treeCount += d.properties['TreeCount'];
        meanIncomeSum += d.properties["est household mean income"];
      })

      let meanIncome = meanIncomeSum / geodata.features.length

      return [treeCount, meanIncome]
    }
    //legend function from INFO 3300 lecture notes
    function drawLegend(legendSelector, legendColorScale, stringFormatter) {

      const offsets = {
        width: 30,
        top: 2,
        bottom: 24
      };

      const stepSize = 4;

      const minMaxExtendPercent = 0;


      const legend = d3.select(legendSelector);
      const legendHeight = legend.attr("height");
      const legendBarWidth = legend.attr("width") - (offsets.width * 2);
      const legendMinMax = d3.extent(legendColorScale.domain());


      const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
      const barHeight = legendHeight - offsets.top - offsets.bottom;


      let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
      legendMinMax[1] + minMaxExtension])
        .range([0, legendBarWidth - 10]);
      let barAxis = d3.axisBottom(barScale);


      let bar = legend.append("g")
        .attr("class", "legend colorbar")
        .attr("transform", `translate(${offsets.width},${offsets.top})`)


      if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
        let thresholds = [];
        if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
        else { thresholds = legendColorScale.quantiles() }

        let barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

        barAxis.tickValues(barThresholds).tickFormat(stringFormatter);

        for (let i = 0; i < barThresholds.length - 1; i++) {
          let dataStart = barThresholds[i]; let dataEnd = barThresholds[i + 1];
          let pixelStart = barAxis.scale()(dataStart); let pixelEnd = barAxis.scale()(dataEnd); bar.append("rect").attr("x",
            pixelStart).attr("y", 0).attr("width", pixelEnd - pixelStart).attr("height", barHeight).style("fill",
              legendColorScale((dataStart + dataEnd) / 2.0));
        }
      } else if (legendColorScale.hasOwnProperty('rangeRound')) {
        for
          (let i = 0; i < legendBarWidth; i = i + stepSize) {
          let center = i + (stepSize / 2); let
            dataCenter = barAxis.scale().invert(center); if (dataCenter < legendMinMax[0]) {
              bar.append("rect").attr("x", i)
                .attr("y", 0).attr("width", stepSize).attr("height", barHeight).style("fill", legendColorScale(legendMinMax[0]));
            } else if (dataCenter < legendMinMax[1]) {
              bar.append("rect").attr("x", i).attr("y", 0).attr("width", stepSize)
                .attr("height", barHeight).style("fill", legendColorScale(dataCenter));
            } else {
            bar.append("rect").attr("x", i)
              .attr("y", 0).attr("width", stepSize).attr("height", barHeight).style("fill", legendColorScale(legendMinMax[1]));
          }
        }
      } else {
        let nomVals = legendColorScale.domain().sort(); let barScale = d3.scaleBand().domain(nomVals).range([0,
          legendBarWidth]).padding(0.05); barAxis.scale(barScale); nomVals.forEach(d => {
            bar.append("rect")
              .attr("x", barScale(d))
              .attr("y", 0)
              .attr("width", barScale.bandwidth())
              .attr("height", barHeight)
              .style("fill", legendColorScale(d));
          });
      }

      legend.append("g")
        .attr("class", "legend axis")
        .attr("class", "colorLegendfont")
        .attr("transform", `translate(${offsets.width},${offsets.top + barHeight + 5})`)
        .call(barAxis);

    }

  </script>

  <script>

    const requestDataPF = async function () {
      var data_pm = await d3.csv("./global_power_plant_database.csv", d3.autoType);
      var countries_continents = await d3.csv("./continents-according-to-our-world-in-data.csv", d3.autoType);
      console.log(countries_continents);
      console.log(data_pm)
      const countryToContinent = {};
      countries_continents.forEach(entry => {
        const country = entry.Entity.trim();
        const continent = entry.Continent.trim();
        countryToContinent[country] = continent;
      });
      console.log(countryToContinent);


      const groupedData = {};
      data_pm.forEach(d => {
        const continent = countryToContinent[d.country_long];
        if (!continent) return; // handle invalid

        if (!groupedData[continent]) {
          groupedData[continent] = {};
        }

        if (!groupedData[continent][d.primary_fuel]) {
          groupedData[continent][d.primary_fuel] = 0;
        }

        groupedData[continent][d.primary_fuel]++;
      });


      console.log(groupedData);
      const continentss = Object.keys(groupedData);

      const totalPerContinent = {};
      for (const continent in groupedData) {
        const key = `${continent}`;
        totalPerContinent[continent] = d3.sum(Object.values(groupedData[continent]));
      }
      console.log(totalPerContinent)
      console.log(continentss)

      const svg = d3.select("#primaryfuel");
      const margin = { top: 0, right: 150, bottom: 50, left: 60 };
      const width = svg.attr("width") - margin.left - margin.right;
      const height = svg.attr("height") - margin.top - margin.bottom;
      const g = svg.append("g")


      const continents = ["Africa", "Antarctica", "Asia", "Europe", "North America", "Oceania", "South America"];

      const stackedData = [];
      Object.keys(groupedData).forEach(continent => {

        const fuels = Object.keys(groupedData[continent]);

        const entry = {
          continent: continent
        };

        fuels.forEach(fuel => {
          entry[fuel] = groupedData[continent][fuel];
        });

        stackedData.push(entry);

      });


      console.log(stackedData)
      const continent = stackedData.map(d => d.continent);

      // Create index 
      const index = d3.index(stackedData, d => d.continent);

      // Access counts
      const value = (d, fuel) => d.get(fuel);

      const stack = d3.stack()
        .keys(primaryFuelTypes)
        .value((d, key) => {
          const row = index.get(d); // Get data object 
          return row[key]; // Return value 
        })
        .order(d3.stackOrderDescending);



      var series = stack(continent);

      console.log(series)

      const stackedSeries = primaryFuelTypes.map(fuel => {
        return {
          key: fuel,
          values: continents.map(c => groupedData[c][fuel] || 0)
        }
      });

      console.log(stackedSeries);

      const x = d3.scaleBand()
        .domain(stackedData.map(d => d.continent))
        .range([0, width])
        .padding([0.2]);

      const y = d3.scaleLinear()
        .domain([0, d3.max(series, c => d3.max(c, (d => d[1]) || 0)) + 620])
        .rangeRound([height, 0]);



      const total = d3.extent(Object.values(totalPerContinent))

      svg.append("g")
        .selectAll(".continent")
        .data(series)
        .join("g")
        .attr("fill", d => colorScale(d.key))
        .selectAll("rect")
        .data(d => d)
        .join("rect")
        .attr("x", (d, i) => x(continent[i]))
        .attr("y", d => y(d[1]))
        .attr("height", d => (y(d[0]) - y(d[1])) || 0)
        .attr("width", x.bandwidth())
        .attr("transform", `translate(${margin.left},0)`);


      svg.append("g")
        .selectAll()
        .data(series)
        .join("g")
        .selectAll("text")
        .data(d => d.map(v => ({ ...v, key: d.key, value: v[1] - v[0] })))
        .join("text")
        .text(d => d.value)
        .attr("visibility", d => d.value >= 600 ? "visible" : "hidden")
        .attr("x", (d, i) => x(continent[i]) + x.bandwidth())
        .attr("y", d => ((y(d[1]) + y(d[0])) / 2 || 0))
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .attr('style', 'font-size:10pt;')
        .attr('fill', 'white');

      // Add labels on top of the bars
      svg.selectAll(".labels")
        .data(series)
        .enter()
        .append("text")
        // .attr("x", (d, i) => (x(continent[i]))||0)
        .attr("x", (d, i) => (x(continent[i]) || 0) + x.bandwidth())
        // .attr("y", d => (y(d[0])) || 0)  
        .attr("y", (d, i) => {
          cont = ((continent[i]))
          return y(totalPerContinent[cont] || 0)
        })
        .text((d, i) => {
          cont = ((continent[i]))
          return (d3.format(',')(totalPerContinent[cont] || 0));
        })
        .attr("visibility", (d, i) => (totalPerContinent[(continent[i])] > 0) ? "visible" : "hidden")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .attr('style', 'font-size:10pt;')
        .attr('style', 'color: black;')
        .attr('fill', 'black')
        .attr("transform", `translate(5, ${-10})`);





      // axes
      svg.append("g")
        .attr("transform", `translate(${margin.left}, ${height})`)
        .call(d3.axisBottom(x));

      svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y))



      const legend = svg.append("g")
        .attr("transform", `translate(${width + 75},20)`)


      legend.selectAll("rect")
        .data(primaryFuelTypes)
        .join("rect")
        .attr("y", (d, i) => i * 20)
        .attr("width", 10)
        .attr("height", 10)
        .attr("fill", d => colorScale(d));

      legend.selectAll("text")
        .data(primaryFuelTypes)
        .join("text")
        .attr("y", (d, i) => i * 20 + 9)
        .attr("x", 12)
        .text(d => d)
        .attr("fill", "black");


    }
    requestDataPF();
  </script>

  <script>
    const requestDataCountry = async function () {
      var data_pm = await d3.csv("./global_power_plant_database.csv", d3.autoType);

      // Group power plant capacities by country and type of fuel
      const groupedData = {};
      data_pm.forEach(d => {
        if (!groupedData[d.country_long]) {
          groupedData[d.country_long] = {};
        }

        if (!groupedData[d.country_long][d.primary_fuel]) {
          groupedData[d.country_long][d.primary_fuel] = 0;
        }

        groupedData[d.country_long][d.primary_fuel] += d.capacity_mw;
      });

      // Sort countries by total capacity and select top 10
      var sortedCountries = Object.keys(groupedData).sort((a, b) => {
        const totalCapacityA = Object.values(groupedData[a]).reduce((acc, val) => acc + val, 0);
        const totalCapacityB = Object.values(groupedData[b]).reduce((acc, val) => acc + val, 0);
        return totalCapacityB - totalCapacityA;
      }).slice(0, 10);


      // Prepare data for stacked bar chart
      const stackedData = sortedCountries.map(country => {
        const entry = { country };
        primaryFuelTypes.forEach(fuel => {
          entry[fuel] = groupedData[country][fuel] || 0;
        });
        return entry;
      });

      console.log(stackedData)

      // Setup SVG dimensions and margins
      const svg = d3.select("#pfCountry");
      const margin = { top: 20, right: 150, bottom: 70, left: 60 };
      const width = +svg.attr("width") - margin.left - margin.right;
      const height = +svg.attr("height") - margin.top - margin.bottom;
      const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

      // Setup scales
      const x = d3.scaleBand()
        .domain(sortedCountries)
        .range([0, width])
        .padding(0.1);

      const y = d3.scaleLinear()
        .domain([0, d3.max(stackedData, d => d3.sum(primaryFuelTypes.map(fuel => d[fuel])))])
        .nice()
        .rangeRound([height, 0]);


      // Setup stack generator
      const stack = d3.stack()
        .keys(primaryFuelTypes)
        .order(d3.stackOrderDescending)
        .offset(d3.stackOffsetNone);

      // Generate stacked data
      const series = stack(stackedData);

      // Append bars
      g.selectAll(".serie")
        .data(series)
        .join("g")
        .attr("class", "serie")
        .attr("fill", d => colorScale(d.key))
        .selectAll("rect")
        .data(d => d)
        .join("rect")
        .attr("x", d => x(d.data.country))
        .attr("y", d => y(d[1]))
        .attr("height", d => y(d[0]) - y(d[1]))
        .attr("width", x.bandwidth());

      // Append axes
      g.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x))
      // .selectAll("text")
      // .attr("y", 0)
      // .attr("x", 9)
      // // .attr("dy", ".35em")
      // // .attr("transform", "rotate(90)")
      // .style("text-anchor", "start");

      g.append("g")
        .attr("class", "axis")
        .call(d3.axisLeft(y).ticks(null, "s"))
        .append("text")
        .attr("x", 2)
        .attr("y", y(y.ticks().pop()) + 0.5)
        .attr("dy", "0.32em")
        .attr("fill", "#000")
        .attr("font-weight", "bold")
        .attr("text-anchor", "start")
        .text("Capacity (MW)");

      // Append legend

      // const legend = g.append("g")
      //     .attr("font-family", "sans-serif")
      //     .attr("font-size", 10)
      //     .attr("text-anchor", "end")
      //     .selectAll("g")
      //     .data(fuelTypes.slice())
      //     .join("g")
      //     .attr("transform", (d, i) => `translate(0,${i * 20})`);

      // legend.append("rect")
      //     .attr("x", width - 19)
      //     .attr("width", 19)
      //     .attr("height", 19)
      //     .attr("fill", color);

      // legend.append("text")
      //     .attr("x", width - 24)
      //     .attr("y", 9.5)
      //     .attr("dy", "0.32em")
      //     .text(d => d);



      const legend = svg.append("g")
        .attr("transform", `translate(${width + 75},20)`)


      legend.selectAll("rect")
        .data(primaryFuelTypes)
        .join("rect")
        .attr("y", (d, i) => i * 20)
        .attr("width", 10)
        .attr("height", 10)
        .attr("fill", d => colorScale(d));

      legend.selectAll("text")
        .data(primaryFuelTypes)
        .join("text")
        .attr("y", (d, i) => i * 20 + 9)
        .attr("x", 12)
        .text(d => d)
        .attr("fill", "black");

    }
    requestDataCountry();
  </script>
  <script>
    const requestDataTopPlants = async function () {
      var data_pm = await d3.csv("./global_power_plant_database.csv", d3.autoType);

      // Sort power plants by capacity_mw and select top 10
      const sortedPlants = data_pm.sort((a, b) => b.capacity_mw - a.capacity_mw).slice(0, 10);

      // Extract fuel types
      const fuelTypes = Array.from(new Set(data_pm.map(entry => entry.primary_fuel)));

      // Setup SVG dimensions and margins
      const svg = d3.select("#powerPlants");
      const margin = { top: 20, right: 150, bottom: 70, left: 60 };
      const width = +svg.attr("width") - margin.left - margin.right;
      const height = +svg.attr("height") - margin.top - margin.bottom;
      const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

      // Setup scales
      const x = d3.scaleBand()
        .domain(sortedPlants.map(d => d.name))
        .range([0, width])
        .padding(0.1);

      const y = d3.scaleLinear()
        .domain([0, d3.max(sortedPlants, d => d.capacity_mw)])
        .nice()
        .rangeRound([height, 0]);

      // Append bars
      g.selectAll(".bar")
        .data(sortedPlants)
        .join("rect")
        .attr("class", "bar")
        .attr("x", d => x(d.name))
        .attr("y", d => y(d.capacity_mw))
        .attr("width", x.bandwidth())
        .attr("height", d => height - y(d.capacity_mw))
        .attr("fill", d => colorScale(d.primary_fuel));

      // Append axes
      g.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x))
        .selectAll("text")
        .attr("dy", "1.5")
        .attr("x", -9)
        .attr("y", 0)
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-45)")
        .call(wrap, x.bandwidth());

      g.append("g")
        .attr("class", "axis")
        .call(d3.axisLeft(y).ticks(null, "s"))
        .append("text")
        .attr("x", 2)
        .attr("y", y(y.ticks().pop()) + 0.5)
        .attr("dy", "0.32em")
        .attr("fill", "#000")
        .attr("font-weight", "bold")
        .attr("text-anchor", "start")
        .text("Capacity (MW)");

      // Append legend
      const legend = svg.append("g")
        .attr("transform", `translate(${width + 75},20)`)


      legend.selectAll("rect")
        .data(primaryFuelTypes)
        .join("rect")
        .attr("y", (d, i) => i * 20)
        .attr("width", 10)
        .attr("height", 10)
        .attr("fill", d => colorScale(d));

      legend.selectAll("text")
        .data(primaryFuelTypes)
        .join("text")
        .attr("y", (d, i) => i * 20 + 9)
        .attr("x", 12)
        .text(d => d)
        .attr("fill", "black");

      function wrap(text, width) {
        text.each(function () {
          var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = text.attr("y"),
            dy = parseFloat(text.attr("dy")),
            tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
          while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
              line.pop();
              tspan.text(line.join(" "));
              line = [word];
              tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
            }
          }
        });

      }
    }

    requestDataTopPlants();
  </script>
</body>

</html>