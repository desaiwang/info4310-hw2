<html>

<head>
  <title>INFO 4310 - HW2</title>

  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <style>
    .countries {
      stroke: white;
      stroke-width: 1px;
      fill: #bbb;
    }

    .tractsTreeCount {
      stroke: white;
      stroke-width: 2px;
    }

    .row {
      display: flex;
      flex-direction: row;
      justify-content: center
    }

    .column {
      display: flex;
      flex-direction: column;
    }

    .annotation {
      font-size: 12px;
      margin-top: -15px;
      margin-left: 40px
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
    .serie rect {
    fill-opacity: 0.8;
    }

    .serie:hover rect {
    fill-opacity: 1;
    } 
  </style>

</head>

<body>
  <div style="margin-top:30px">
    <h2 style="text-align: center"> Exploring Power Plants Around the World</h2>
    <div class="row 1">
      <svg id="mapGlobal" width="1500" height="1000"></svg>
      <div>
        <svg width="300" height="200">
          <text id="plantName" y="10" alignment-baseline="hanging"></text>
          <text id="plantCapacity" y="25" alignment-baseline="hanging"></text>
        </svg>

      </div>
    </div>
    <svg id="map" width="1500" height="1000"></svg>
    <svg id ="primaryFuel" width = "1200" height = "500"></svg>


  </div>

  </div>


  <!-- <script>

    //row 1 elements
    const svgGlobal = d3.select("#mapGlobal");
    const width = svgGlobal.attr("width");
    const height = svgGlobal.attr("height");
    const margin = { top: 20, right: 20, bottom: 20, left: 20 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;

    const viewport = svgGlobal.append("g");
    // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // map geojson
    const requestData = async function () {

      //load power plant data
      const powerPlants = await d3.csv("./global_power_plant_database.csv", d3.autoType);
      const countries = await d3.json("./countries.geojson");

      console.log(powerPlants);
      console.log(countries);

      // Mercator projection
      var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);

      //scales for income and treeCount
      const capacityExtent = d3.extent(powerPlants, d => d["capacity_mw"]);
      const capacityScale = d3.scaleLog()
        .domain(capacityExtent)
        .range([1, 5]);
      console.log(capacityExtent)

      powerPlants.forEach(d => {
        d.Position = projection([d.longitude, d.latitude]);
      })

      // countries for base map
      let countryBoundaries = viewport.selectAll("path.countries").data(countries.features)
        .join("path")
        .attr("class", "countries")
        .attr("d", path);

      // drawLegend("#legendIncome", incomeColorScale, d3.format("$.2s"));

      let circles = viewport.selectAll("circle").data(powerPlants)
        .join("circle")
        .attr("cx", d => d.Position[0])
        .attr("cy", d => d.Position[1])
        .attr("r", d => capacityScale(d["capacity_mw"]))
        .attr("fill", "blue")
        .attr("opacity", 0.5);

      circles.on("mouseover", function () {
        let name = d3.select(this).datum()["name"];
        let capacity = d3.select(this).datum()["capacity_mw"];

        d3.select("#plantName").text(`Name: ${name}`);
        d3.select("#plantCapacity").text(`Capacity: ${capacity} mW`);
      });

      circles.on("mouseout", function () {
        d3.select("#plantName").text("");
        d3.select("#plantCapacity").text("");
      });

      // // census tracts for tree count map
      // mapTreeCount.selectAll("path.tractsTreeCount").data(tracts.features)
      //   .join("path")
      //   .attr("class", "tractsTreeCount")
      //   .attr("d", path)
      //   .attr("fill", d => treeCountColorScale(d.properties["TreeCount"]));
      // drawLegend("#legendTreeCount", treeCountColorScale, d3.format(".2s"));

      var zoom = d3.zoom()
        // .scaleExtent([1, 20])
        // .translateExtent([[-50, -50], [mapWidth + 50, mapHeight + 50]])  // to lock to edges
        .on("zoom", mapZoomed);

      // viewport.on(".zoom", function (event) {
      //   console.log(event);
      // })

      svgGlobal.call(zoom);
      svgGlobal.call(zoom.transform, d3.zoomIdentity);

      // from INFO3300 lecture on panning and zooming
      function mapZoomed({ transform }) {

        console.log(transform);
        // Transform the group object to reflect the zoom action
        viewport.attr("transform", transform.toString());
        // NOTE: we could also instead adjust projection and path to account for the zoom
        //  However, projections can be time-consuming to calculate, leading to laggy interactions
        //  For some projections like orthographic, you need to recompute the projection to deliver a
        //   consistent user experience (e.g. adjust lambda for the projection to rotate the globe)

        // Divide by scale to make sure strokes remain a consistent width during zooming
        countryBoundaries
          .style("stroke-width", 1 / transform.k);
        circles.attr("r", d => capacityScale(d["capacity_mw"]) / transform.k);
        // console.log(viewport.select(".plantLocation"));

        // Expose county layer when sufficiently zoomed
        // viewport.select(".county-outline")
        //   .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
        // viewport.selectAll(".county")
        //   .attr("visibility", (transform.k > 3) ? "visible" : "hidden");

      }

    }
    // requestData();
  </script>

  <script id="helper function">

    function sumTreeCount_avgMeanIncome(geodata) {
      let treeCount = 0;
      let meanIncomeSum = 0;

      geodata.features.forEach(d => {
        treeCount += d.properties['TreeCount'];
        meanIncomeSum += d.properties["est household mean income"];
      })

      let meanIncome = meanIncomeSum / geodata.features.length

      return [treeCount, meanIncome]
    }
    //legend function from INFO 3300 lecture notes
    function drawLegend(legendSelector, legendColorScale, stringFormatter) {

      const offsets = {
        width: 30,
        top: 2,
        bottom: 24
      };

      const stepSize = 4;

      const minMaxExtendPercent = 0;


      const legend = d3.select(legendSelector);
      const legendHeight = legend.attr("height");
      const legendBarWidth = legend.attr("width") - (offsets.width * 2);
      const legendMinMax = d3.extent(legendColorScale.domain());


      const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
      const barHeight = legendHeight - offsets.top - offsets.bottom;


      let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
      legendMinMax[1] + minMaxExtension])
        .range([0, legendBarWidth - 10]);
      let barAxis = d3.axisBottom(barScale);


      let bar = legend.append("g")
        .attr("class", "legend colorbar")
        .attr("transform", `translate(${offsets.width},${offsets.top})`)


      if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
        let thresholds = [];
        if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
        else { thresholds = legendColorScale.quantiles() }

        let barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

        barAxis.tickValues(barThresholds).tickFormat(stringFormatter);

        for (let i = 0; i < barThresholds.length - 1; i++) {
          let dataStart = barThresholds[i]; let dataEnd = barThresholds[i + 1];
          let pixelStart = barAxis.scale()(dataStart); let pixelEnd = barAxis.scale()(dataEnd); bar.append("rect").attr("x",
            pixelStart).attr("y", 0).attr("width", pixelEnd - pixelStart).attr("height", barHeight).style("fill",
              legendColorScale((dataStart + dataEnd) / 2.0));
        }
      } else if (legendColorScale.hasOwnProperty('rangeRound')) {
        for
          (let i = 0; i < legendBarWidth; i = i + stepSize) {
          let center = i + (stepSize / 2); let
            dataCenter = barAxis.scale().invert(center); if (dataCenter < legendMinMax[0]) {
              bar.append("rect").attr("x", i)
                .attr("y", 0).attr("width", stepSize).attr("height", barHeight).style("fill", legendColorScale(legendMinMax[0]));
            } else if (dataCenter < legendMinMax[1]) {
              bar.append("rect").attr("x", i).attr("y", 0).attr("width", stepSize)
                .attr("height", barHeight).style("fill", legendColorScale(dataCenter));
            } else {
            bar.append("rect").attr("x", i)
              .attr("y", 0).attr("width", stepSize).attr("height", barHeight).style("fill", legendColorScale(legendMinMax[1]));
          }
        }
      } else {
        let nomVals = legendColorScale.domain().sort(); let barScale = d3.scaleBand().domain(nomVals).range([0,
          legendBarWidth]).padding(0.05); barAxis.scale(barScale); nomVals.forEach(d => {
            bar.append("rect")
              .attr("x", barScale(d))
              .attr("y", 0)
              .attr("width", barScale.bandwidth())
              .attr("height", barHeight)
              .style("fill", legendColorScale(d));
          });
      }

      legend.append("g")
        .attr("class", "legend axis")
        .attr("class", "colorLegendfont")
        .attr("transform", `translate(${offsets.width},${offsets.top + barHeight + 5})`)
        .call(barAxis);

    }

  </script> -->

  <script>
    const requestDataPF = async function () {
    var data_pm = await d3.csv("./global_power_plant_database.csv", d3.autoType);
    var countries_continents = await d3.csv("./continents-according-to-our-world-in-data.csv", d3.autoType);
    console.log(countries_continents);
    console.log(data_pm)
    const countryToContinent = {};
    countries_continents.forEach(entry => {
                    const country = entry.Entity.trim();
                    const continent = entry.Continent.trim();
                    countryToContinent[country] = continent;
                });
    console.log(countryToContinent);
  
    // // Group data by continent and primary fuel
    // const groupedData = data_pm.reduce((acc, curr) => {
    //                 const continent = countryToContinent[curr.country_long];
    //                 if (!continent) {
    //                     console.log(`Continent undefined for country: ${curr.country_long}`);
    //                 }
    //                 if (!acc[continent]) {
    //                     acc[continent] = {};
    //                 }
    //                 const key = `${curr.primary_fuel}`;
    //                 if (!acc[continent][key]) {
    //                     acc[continent][key] = 0;
    //                 }
    //                 acc[continent][key]++;
    //                 return acc;
    //             }, {});]

    const groupedData = {};
    data_pm.forEach(d => {
        const continent = countryToContinent[d.country_long];
        if(!continent) return ; // handle invalid
        
        if(!groupedData[continent]) {
          groupedData[continent] = {}; 
        }
        
        if(!groupedData[continent][d.primary_fuel]) {
          groupedData[continent][d.primary_fuel] = 0; 
        }
        
        groupedData[continent][d.primary_fuel]++;
      });


    console.log(groupedData);
    const continentss = Object.keys(groupedData);
    const primaryFuels = [...new Set(data_pm.map(entry => entry.primary_fuel))];
   
    const totalPerContinent = {};
    for (const continent in groupedData) {
        const key = `${continent}`;
        totalPerContinent[continent] = d3.sum(Object.values(groupedData[continent]));
    }
    console.log(totalPerContinent)
    console.log(continentss)
    console.log(primaryFuels)

    const svg = d3.select("#primaryfuel");
    const margin = { top: 20, right: 150, bottom:50, left: 60};
    const width = svg.attr("width") - margin.left - margin.right;  
    const height = svg.attr("height")- margin.top - margin.bottom;
    const g = svg.append("g")
    // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    // const stackedData = continentss.map(continent => {
    // return {
    //     continent: continent,
    //     values: primaryFuels.map(fuel => ({ fuel: fuel, count: groupedData[continent][fuel] || 0 }))
    // };
    // });


// const stackedData = continentss.map(c => {
//   return primaryFuels.map(fuel => ({
//       continent: c,
//       fuel: fuel, 
//       value: groupedData[c][fuel] || 0
//   })); 
// })

//THIS IS THE ONE YOU COMMENTED OUT:
// const stackedData = continentss.map(c => {
//     return {
//         continent: c,
//         values: primaryFuels.map(fuel => ({
//             fuel: fuel,
//             count: groupedData[c][fuel] || 0
//         }))
//     };
// });

    const continents = ["Africa", "Antarctica", "Asia", "Europe", "North America", "Oceania", "South America"];

    const stackedData = [];
    Object.keys(groupedData).forEach(continent => {

      const fuels = Object.keys(groupedData[continent]);  

      const entry = {
        continent: continent 
      };

      fuels.forEach(fuel => {
        entry[fuel] = groupedData[continent][fuel]; 
      });

      stackedData.push(entry);

      });
      // Object.keys(groupedData).forEach(continent => {
      //   const fuels = Object.keys(groupedData[continent]);
      //   stackedData.push({
      //     continent: continent,
      //     fuels: fuels.map(fuel => ({
      //       fuel: fuel,
      //       value: groupedData[continent][fuel]
      //     }))
      //   }); 
      // });

      console.log(stackedData)
      const continent = stackedData.map(d => d.continent);

      // Create index 
      const index = d3.index(stackedData, d => d.continent);  

      // Access counts
      const value = (d, fuel) => d.get(fuel); 

      const stack = d3.stack()
        .keys(primaryFuels)
        .value( (d, key) => {
        const row = index.get(d); // Get data object 
        return row[key]; // Return value 
      });

      const series = stack(continent);
      console.log(series)



    // stackedData.forEach(d => {
    //   Object.values(d).forEach(v => v += 10);  
    // });


    /* 
    // create stack data
    const series = d3.stack()
  .keys (pop_trees_by_counts)
  .value((L, group], key) => group. get (key) . Count) (d3. index (data, d => d.Neighborhood, d => d. qSpecies) );
    
    *///YOU ALSO COMMENTED  OUT BELOW HERE LATEST:
    // console.log(stackedData)
    // const series = d3.stack()
    //   .keys(primaryFuels)
    //   .value(d => d.count)(stackedData.map(c => c.values));
      // .value(([, fuels], fuel) => fuels[fuel].count)(d3.index(stackedData, d => d.continent, d => d.values))
      // .order(d3.stackOrderNone)
      // .offset(d3.stackOffsetNone);

    // const stackedSeries = stack(continents.map(c => {
    //   // return Object.values(groupedData[c]).filter(d => d > 0) ;  
    //   return primaryFuels.map(fuel => groupedData[c][fuel] || 0)
    // }));
  //     const stackedSeries = stack(primaryFuels.map(fuel => {
  //   return continents.map(c => groupedData[c][fuel] || 0) 
  // }));

  const stackedSeries = primaryFuels.map(fuel => {
  return {
    key: fuel, 
    values: continents.map(c => groupedData[c][fuel] || 0)
  }
});

    console.log(stackedSeries);

    const x = d3.scaleBand()
      .domain(stackedData.map(d => d.continent))
      .range([0, width])
      .padding([0.2]); 

    const y = d3.scaleLinear()
    .domain([0, d3.max(series, c => d3.max(c, d => d[1]))])  
    // .domain([0, d3.max(stackedSeries, series => {
    // return d3.max(series.values)  
    //   })
    //   ])
    .rangeRound([height, 0]);

  

    const color = d3.scaleOrdinal()
    .domain(primaryFuels)
    .range(d3.schemeCategory10)
  
//         // create stack data
//         const series = d3.stack()
//           .keys(primaryFuels)
//           .value(([, group], key) => group.get(key).count)
//           (d3.index(stackedData, d => d.continent, d => d.count));
//           // ([groupedData])

//         console.log(series);
          // .value(([, group], key) => group.get(key).Count)
          // (d3.index(data, d => d.Neighborhood, d => d.qSpecies));


      const total = d3.extent(Object.values(totalPerContinent))

      svg.append("g")
        .selectAll(".continent")
        .data(series)
        .join("g")
          .attr("fill", d => color(d.key))  
          .selectAll("rect")
          .data(d => d) 
          .join("rect")
            .attr("x", (d, i) => x(continents[i]))  
            .attr("y", d => y(d[1]))
            .attr("height", d => y(d[0]) - y(d[1]))
            .attr("width", x.bandwidth()); 

      // svg.append("g")
      //   .selectAll("g")
      //   .data(stackedSeries)
      //   .join("g")
      //   .attr("fill", d => color(d.key))
      //   .selectAll("rect")
      //   .data(d => d)
      //   .join("rect")
      //   .attr("x", (d, i) => x(continents[i]))
      //   .attr("y", d => y(d[1]))
      //   .attr("height", d =>(y(d[0]) - y(d[1])))
      //   .attr("width", x.bandwidth())
        // .attr("transform", `translate(500,0)`);


        // axes
        svg.append("g")
          .attr("transform", `translate(${margin.left}, ${height})`)
          .call(d3.axisBottom(x)); 

        svg.append("g")
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y))



        const legend = svg.append("g")
            .attr("transform", `translate(${width+75},20)`)


          legend.selectAll("rect") 
              .data(primaryFuels)
              .join("rect")
                .attr("y", (d, i) => i * 20)  
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", d => color(d)); 

          legend.selectAll("text")
              .data(primaryFuels)
              .join("text")
                .attr("y", (d, i) => i * 20 + 9) 
                .attr("x", 12) 
                .text(d => d)
                .attr("fill", "black");
        
    }
    requestDataPF();
  </script>
</body>

</html>