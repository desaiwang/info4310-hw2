<html>

<head>
  <title>INFO 4310 - HW2</title>
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  <link href="./style.css" rel="stylesheet" type="text/css">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>
  <style>
    .countries {
      stroke: white;
      stroke-width: 1px;
      fill: #bbb;
    }

    .row {
      display: flex;
      flex-direction: row;
      justify-content: center
    }


    .column {
      display: flex;
      flex-direction: column;
    }

    .annotation {
      font-size: 12px;
      margin-top: -15px;
      margin-left: 40px
    }

    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }

    .serie rect {
      fill-opacity: 0.8;
    }

    .serie:hover rect {
      fill-opacity: 1;
    }

    /* .test {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    } */
  </style>

</head>

<body>
  <div style="margin-top:30px">
    <h2 style="text-align: center"> Exploring Power Plants Around the World</h2>
    <h5 style="text-align: center; margin-top: -65px; margin-bottom: 50px"> Natalia Jordan (naj46) and Desai Wang
      (dw584)</h5>

    <div>
      <div id="container" style="width: 1000px; height: 600px;">
        <svg id="mapTile" width="1000" height="600"></svg>
      </div>

      <div id="controlfilter" class="test" style="padding-top:10px;padding-bottom:10px">
      </div>

    </div>
    <div id="legendTest" width="1000" height="600"></div>
    <svg id="legendSvg" width="1000" height="600"></svg>




    <div style="margin-top:100px">
      <svg id="primaryFuel" width="1200" height="500"></svg>
      <svg id="pfCountry" width="1200" height="500"></svg>
      <svg id="powerPlants" width="1200" height="500"></svg>
    </div>





  </div>
  <script>

    const container = d3.select("#container").style("position", "relative");

    const mapArea = d3.select("#mapTile");

    const width = mapArea.attr("width");
    const height = mapArea.attr("height");

    const canvas = container.append("canvas")
      .attr("width", width)
      .attr("height", height)
      .style("position", "absolute")
      .style("top", 0)
      .style("left", 0);
    const context = canvas.node().getContext('2d');

    const interactiveArea = container.append("svg")
      .attr("width", width)
      .attr("height", height)
      .style("position", "absolute")
      .style("top", 0)
      .style("left", 0);

    const labelBase = interactiveArea.append("rect")
      .attr("x", 10).attr("y", 10)
      .attr("width", 350).attr("height", 50)
      .attr("fill", "white")
      .attr("opacity", "0.5");

    const labels = interactiveArea.append("g");
    const labelName = labels.append("text").attr("x", 20).attr("y", 30).text("Hover over a power plant for more information.");
    const labelFuel = labels.append("text").attr("x", 20).attr("y", 50).text("Bigger circle means larger production capacity.");
    const labelCapacity = labels.append("text").attr("x", 20).attr("y", 70);
    const labelCountry = labels.append("text").attr("x", 20).attr("y", 90);



    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/clswj0z9q00oq01p4ao6scxlh/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`


    //establish color mapping for fuel types
    const primaryFuelTypes = ['Solar', 'Wind', 'Hydro', 'Wave and Tidal', 'Geothermal', 'Biomass', 'Gas', 'Oil', 'Nuclear', 'Coal', 'Waste', 'Petcoke', 'Storage', 'Cogeneration', 'Other'];

    const primaryFuelFilter = [true, true, true, true, true, true, true, true, true, true, true, true, true, true, true];

    colors = [
      "#b2df8a",
      "#a6cee3",
      "#1f78b4",
      "#33a02c",
      "#ff7f00",
      "#fb9a99",
      "#e31a1c",
      "#fdbf6f",
      "#cab2d6",
      "#6a3d9a",
      "#b15928",
      "#000000",
      "#cccccc",
      "#fdda24",
      "#b15928"
    ];

    const colorScale = d3.scaleOrdinal()
      .domain(primaryFuelTypes)
      .range(colors);

    // const legend = d3.select("#legendTest").append("g")
    const legend = d3.select("#legendSvg").append("g")
    // .attr("transform", `translate(${width + 75},20)`)

    // <input type="checkbox" id="myCheckbox" style="accent-color:red"> Only Even</input>

    // testtt = legend.selectAll("input")
    //   .data(primaryFuelTypes)
    //   .enter()
    //   .append("label")
    //   .attr('for', function (d, i) { return 'a' + i; })
    //   .text(d => d)
    //   .append("input")
    //   .attr("type", "checkbox")
    //   .attr("checked", true)
    //   .attr("name", function (d, i) { return 'a' + i; })
    //   // .attr("y", (d, i) => i * 20)
    //   // .text(d => d)
    //   // .attr("width", 10)
    //   // .attr("height", 10)
    //   .style("accent-color", d => colorScale(d))

    // testtt = legend.selectAll("input")
    //   .data(primaryFuelTypes)
    //   .enter()
    //   .append("label")
    //   .attr('for', function (d, i) { return 'a' + i; })
    //   .each(function (d, i) {
    //     d3.select(this)
    //       .append("input")
    //       .attr("type", "checkbox")
    //       .attr("checked", true)
    //       .attr("name", function (d, i) { return 'a' + i; });

    //     d3.select(this)
    //       .append("span")
    //       .text(d => d);
    //   })
    //   .style("accent-color", d => colorScale(d));

    // legend.selectAll("rect")
    //   .data(primaryFuelTypes)
    //   .join("rect")
    //   .attr("y", (d, i) => i * 20)
    //   .attr("width", 10)
    //   .attr("height", 10)
    //   .attr("fill", d => colorScale(d))
    //   .attr("stroke", "#bbb")
    //   .attr("stroke-width", 2)
    //   .attr("index", (d, i) => i)
    //   .on("mouseover", function () {
    //     d3.select(this).attr("opacity", 0.5);
    //   })
    //   .on("mouseout", function () {
    //     d3.select(this).attr("opacity", 1);
    //   })
    //   .on("click", function (d, i) {

    //     var clicked = d3.select(this);
    //     // console.log(index)
    //     d3.select(this).attr("clicked", clicked);

    //     console.log(d3.select(this));
    //     console.log(d3.select(this).data());

    //     if (clicked === true) {
    //       d3.select(this).attr("fill", d => colorScale(d));
    //     } else {
    //       d3.select(this).attr("fill", "white");
    //     }
    //   });

    legend.selectAll("rect")
      .data(primaryFuelTypes)
      .join("rect")
      .attr("y", (d, i) => i * 20)
      .attr("width", 10)
      .attr("height", 10)
      .attr("fill", d => colorScale(d))
      .attr("stroke", "#bbb")
      .attr("stroke-width", 2)
      .attr("clicked", "true")
      .on("mouseover", function () {
        d3.select(this).attr("opacity", 0.5);
      })
      .on("mouseout", function () {
        d3.select(this).attr("opacity", 1);
      })
      .on("click", function (d, i) {

        var clicked = d3.select(this).attr("clicked");

        if (clicked === "true") {

          d3.select(this)
            .attr("fill", "white")
            .attr("clicked", "false");
        } else {

          d3.select(this)
            .attr("fill", d => colorScale(d))
            .attr("clicked", "true");
        }
      });

    legend.selectAll("text")
      .data(primaryFuelTypes)
      .join("text")
      .attr("y", (d, i) => i * 20 + 9)
      .attr("x", 12)
      .text(d => d)
      .attr("fill", "black");

    const requestZoomableMapData = async () => {

      //load power plant data
      const powerPlantsAll = await d3.csv("./global_power_plant_database.csv", d3.autoType);
      const countries = await d3.json("./countries.geojson");
      // console.log(powerPlants);

      // Mercator projection
      var projection = d3.geoMercator().scale(1 / (2 * Math.PI)).translate([0, 0]);
      //d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);

      // power capacity
      const capacityExtent = d3.extent(powerPlantsAll, d => d["capacity_mw"]);
      const capacityScale = d3.scaleLog()
        .domain(capacityExtent)
        .range([1, 5]);


      powerPlantsAll.forEach(d => {
        d.Position = projection([d.longitude, d.latitude]);
        d.Color = colorScale(d["primary_fuel"]);
        d.Radius = capacityScale(d["capacity_mw"]);
      })

      //create a copy used for filtering
      let powerPlants = powerPlantsAll;

      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = mapArea.append("g")
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      var zoom = d3.zoom()
        .scaleExtent([1 << 10, 1 << 19])
        .on("zoom", ({ transform }) => zoomed(transform));


      let initialTransform = d3.zoomIdentity
        .translate(width / 2, height / 2 + 100)
        .scale(1 << 10);
      let currTransform = initialTransform;
      let currentTarget = -1;

      interactiveArea
        .call(zoom)
        .call(zoom.transform, initialTransform)
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {
        if (currentTarget > 0) { mouseExited(); } //disable highlighting while zooming

        currTransform = transform;

        console.log(transform);
        context.save();
        context.clearRect(0, 0, width, height);
        context.globalAlpha = 0.6;
        context.translate(transform.x, transform.y);
        context.scale(transform.k, transform.k);
        context.beginPath();

        powerPlants.forEach((d, i) => {
          let x = d.Position[0];
          let y = d.Position[1];
          let rad = d.Radius;
          let color = d.Color;

          context.fillStyle = color;
          context.beginPath();
          context.arc(x, y, rad / transform.k, 0, 2 * Math.PI);
          context.fill();
        });
        context.restore();

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);

          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);
        });

        if (currentTarget > 0) { mouseEntered(currentTarget); }

      }


      //setting up interactivity and annotations
      let delaunay = d3.Delaunay.from(powerPlants, d => d.Position[0], d => d.Position[1]);
      interactiveArea.on("mousemove", function (event) {

        let loc = d3.pointer(event);

        loc_x = (loc[0] - currTransform.x) / currTransform.k;
        loc_y = (loc[1] - currTransform.y) / currTransform.k;

        // console.log(currTransform)
        // console.log(loc[0], loc[1]);
        // console.log(loc_x, loc_y);

        let index;
        if (currentTarget === -1) {
          // Does a sweep of triangles, which should be O(sqrt(N)) in most cases
          index = delaunay.find(loc_x, loc_y);   // returns index of closest point
        }
        else {
          // With a known point index that's nearby, you can speed up the lookups dramatically
          index = delaunay.find(loc_x, loc_y, currentTarget)
        }
        // console.log(loc, index);

        if (index !== currentTarget) {
          // Make our "mouseover" function
          console.log("mouseover");
          currentTarget = index;
          mouseExited();
          mouseEntered(index, loc[0], loc[1]);
        }
      });
      // Also trigger "mouseout" when leaving interactive area
      interactiveArea.on("mouseout", () => {
        currentTarget = -1;
        mouseExited();
      })


      let setName = "";
      function mouseEntered(i) {
        let d = powerPlants[i];

        interactiveArea.append("circle")
          .attr("id", "highlight")
          .attr("cx", d.Position[0] * currTransform.k + currTransform.x)
          .attr("cy", d.Position[1] * currTransform.k + currTransform.y)
          .attr("r", 5)
          .attr("stroke", "black")
          .attr("fill", "none")
          // .attr("transform", `translate(${currTransform.x}, ${currTransform.y})`)
          // .attr("transform", `scale(${currTransform.k}, ${currTransform.k})`)
          ;

        setName = `Name: ${d['name']}`;
        labelName.text(setName);
        labelFuel.text(`Fuel Type: ${d['primary_fuel']}`);
        labelCapacity.text(`Capacity: ${d3.format(".0f")(d["capacity_mw"])} mW`);
        labelCountry.text(`Location: ${d["country_long"]}`);

        labelBase.attr("opacity", 0.5).attr("width", textWidth()).attr("height", 90);
      }

      context.font = "16px Lato Helvetica";
      function textWidth() {
        let width = context.measureText(setName).width + 50
        return width > 260 ? width : 260;
      }

      function mouseExited() {
        d3.select("#highlight").remove();
        labelBase.attr("opacity", 0);
        labelName.text("");
        labelFuel.text("");
        labelCapacity.text("");
        labelCountry.text("");

      }


      //making dynamic filter, based on INFO 3300 notes

      //filter:

      var filters = {};

      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      //update function after filter applied
      function updateData() {

        // Filter the points using the filter dictionary first
        powerPlants = powerPlantsAll.filter(d => pointPassesFilters(d));
        console.log(powerPlants);

        delaunay = d3.Delaunay.from(powerPlants, d => d.Position[0], d => d.Position[1])

        //updates drawings
        zoomed(currTransform);
      }

      function makeSlider(container, label, attribute, sliderWidth, sliderHeight, maxLimit) {

        // Get a raw array of values for this property
        let values = powerPlantsAll.map(d => d[attribute]).sort(function (a, b) { return b - a }); //sorted for optimization

        // Find min and max for some scales
        let minMax = [0, maxLimit];
        console.log(minMax);
        let xScale = d3.scaleLinear().domain(minMax)
          .range([10, sliderWidth - 20]); // padding here for ease

        let xAxis = d3.axisBottom(xScale)
          .tickFormat(function (d) {
            // console.log("interval", d);
            return (d == maxLimit) ? `> ${maxLimit}` : d;
          })
          ;

        // Create some HTML elements
        let wrapper = container.append("div").attr("class", "controls");
        wrapper.append("div").text(label);

        let rowwrapper = wrapper.append("div")
          .style("display", "flex")
          .style("align-items", "center");

        let canvas = rowwrapper.append("svg").attr("id", "capacity selection")
          .attr("width", sliderWidth)
          .attr("height", sliderHeight + 30)
          .attr("attribute", attribute);
        canvas.append("g").attr("transform", `translate(0,${sliderHeight})`)
          .call(xAxis);

        let buttons = rowwrapper.append("div")
          .style("display", "flex")
          .style("flex-direction", "row")
          .style("justify-content", "center");

        buttons
          .append("button")
          .text("> 500mW")
          .style("margin-right", 8)
          .on("click", function () {
            brushRegion.call(brush.move, null)

            let filterFunc = d => d[attribute] > 500;
            filters[attribute] = filterFunc;

            updateData();
          })

        buttons
          .append("button")
          .text("> 1500mW")
          .style("margin-right", 8)
          .on("click", function () {
            brushRegion.call(brush.move, null)

            let filterFunc = d => d[attribute] > 1500;
            filters[attribute] = filterFunc;

            updateData();
          })

        buttons
          .append("button")
          .style("margin-right", 8)
          .text("top 20 plants by capacity")
          .on("click", function () {
            brushRegion.call(brush.move, null);

            console.log(values);
            let cap = values[19];
            console.log(cap);

            let filterFunc = d => d[attribute] >= cap;
            filters[attribute] = filterFunc;

            updateData();
          })

        // Make an area chart
        let areaLayer = canvas.append("g");

        // generate histogram
        let numBins = 20;
        let histoGen = d3.histogram().domain(minMax)
          .thresholds(numBins);
        let counts = histoGen(values);

        // dummy object at start of graph
        counts.unshift({
          x0: 0,
          x1: counts[0].x0,
          length: counts[0].length
        });

        let yScale = d3.scaleLinear().domain(d3.extent(counts, d => d.length))
          .range([sliderHeight, 10]);

        // Area generator is like a lineGen, but we give y0 and y1 to fill it in
        let area = d3.area().x(d => xScale(d.x1))
          .y0(yScale(0))
          .y1(d => yScale(d.length))
          .curve(d3.curveNatural);

        // Adding the path works just like a line (the area generator just makes a filled region)
        areaLayer.append("path").datum(counts)
          .attr("class", "area")
          .attr("fill", "#9dbbed")
          .attr("d", area);


        let filterFunc = d => true;
        filters[attribute] = filterFunc;

        var brush = d3.brushX().extent([[10, 0], // Upper left corner
        [sliderWidth - 10, sliderHeight]])  // Lower right corner
          .on("brush end", brushMoved);

        function brushMoved(event) {
          console.log(event);

          // Everything but clicking on brush area
          if (event.selection !== null) {

            // Run scales in reverse to get data values for the ends of the brush
            //  If a scale turns data -> pixels, then scale.invert turns pixels -> data
            let start = xScale.invert(event.selection[0]);
            let end = xScale.invert(event.selection[1]);

            if (end > maxLimit - 10) { end = Infinity; } //query all the power stations that are big.

            // Overwrite old filter in our dictionary
            // This filter now only returns True if the point's value is between start and end
            let filterFunc = d => d[attribute] >= start && d[attribute] <= end;
            filters[attribute] = filterFunc;

            updateData();

          }

          // Clicking on brush area to empty it out
          else {
            // Selected nothing, let everything pass
            let filterFunc = d => true;
            filters[attribute] = filterFunc;

            updateData();

          }

        }



        let brushRegion = canvas.append("g").attr("class", "brush")
        brushRegion.call(brush);
      }

      let controls = d3.select("#controlfilter");
      makeSlider(controls, "Capacity (mW)", "capacity_mw", 670, 50, 160);

    }

    requestZoomableMapData();

  </script>
</body>

</html>